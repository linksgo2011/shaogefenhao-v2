---
title: Java 常见技术方案讨论 1
date: 2022-10-15 18:27:46
sidebar: true
head:
- - meta
- name: keyword
  content: Java 常见技术方案讨论,业务单号生成实现的最佳方案
  description: Java 常见技术方案讨论,业务单号生成实现的最佳方案
---

## 《业务单号生成实现的最佳方案》讨论记录

邓老师抛出业务背景和基本方案： 需要业务场景生成业务有意义的编号，比如药品编号。

解决方案：

```text

1. 业务提供一个模板，比如 "YYYY-xxx"来生成业务单号，使用前端调用后端提前（申请式）生成，因为需要在受理业务的时候（还没持久化）就能看到，缺点就是会浪费一些没有存下来的单号。
2. 后端实现为存储了一个当前生成的最大值，如何保证唯一性？连续性？有序性？并发性？可用性？
3. 唯一性使用 Redis 锁最大值实现，可能性能上有瓶颈，但是目前能满足大部分场景，需要在 Redis 配置持久化选项，可以按照周期重置起点。使用 Redission 的原子性操作实现自增，开发者不用关心锁的问题。
4. 业务上不用连续性，也不可能做到连续性。
5. 有序性使用 Redis 的自增特性。
6. 并发性依赖 Redis 的性能，因为生成业务单号逻辑比较简单，并发一般可以接受。

可选方案：

1. 使用数据库行锁，设计一张表，每个前缀一行存储最大值作为计数器，使用 SQL 类似：max = max+1，可以使用 MYSQL 的内存存储引擎。
2. 使用表锁，每次 select max(no) + 1 然后 insert 一条数据到数据库。
3. 使用两张表，一张计数器表（可以使用 Redis 代替） + 单号表，这样避免使用表锁，但是行锁也需要，但是增加了表的数量。
4. 使用 Java 来生成，每个机器的 ID 编入编号，类似于雪花算法，适合 UUID，这个不适合具有业务编号的生成。
5. Range 算法，前面的本质是自增步长为 1，自增步长可以为 N，在内存中使用，顺序性可能受到一定的破坏，服务重启后会浪费一定单号，适合高并发。可以有单独一个服务，但是需要维护。

问题：

1. 如果需要保证连续性怎么做？

比如生成卡号。这个不是一个技术问题，这是一个业务逻辑问题。方案必须要能接受看到的时候和最终持久化的不一致。

2. 多个微服务都需要生成单号怎么设计？如果使用数据库的方案，每个服务都需要生成数据库。

参考下面的解决方案：

   1. 使用 Redis 的方案，使用 SDK 即可，不同的服务配置不同的 Prefix。
   2. 在每个服务中创建独立的计数器表，也可以使用 SDK，并配置一个数据库表和数据源
   3. 使用一个公共服务，比如基础功能服务承载此类需求
   4. 每个服务单独实现一套

推荐方案：

1. 当业务上预生成的单号都需要被管理和跟踪，可以优先考虑使用数据库。
2. 只是单纯的生成一个单号，使用 Redis 比较简单，如果没有 Redis 基础设施，可以可以使用数据库。

遇到的坑：

1. 使用 select count(0) 来获取最大的值，但是这样就需要保证数据不能被删，否则会出现错误，新的单号会重复。
2. Max Value 丢失，Redis 没有持久化或者被删除。解决方案是，手动的提取业务单号的最大值，或者系统启动时候检查，自动修复一次。
3. 如果采用了锁表的方案，会出现性能问题。

```

## 关于后续活动的反馈：

1. 对话题进行分类
2. 将这些整理出来放到一个共享的地方。暂时先放到博客上增加评论功能，后续整理下发布到单独的仓库
3. 后续的活动的安排
4. 将业务单号生成实现为 library，用于后续项目使用

## 录屏和文件分享

链接: https://pan.baidu.com/s/19yp9cUGVrVNz24YkG8OcdQ 提取码: a199 
