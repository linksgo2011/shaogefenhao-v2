---
title: 技术方案 Webinar - 应用缓存设计
date: 2023-05-20 20:54:03
sidebar: true
head:
- - meta
- name: keyword
  content:  缓存设计，Redis，Guava
  description:  如何为应用系统设计一套简洁、安全、高效、清晰的应用缓存策略？
---

## 应用缓存设计问题或痛点

- 超出应用缓存的范畴（只能应用，写出符合缓存友好的代码，很难手动干预）
  - CPU 一二三级缓存。如果是使用数组的 Index 取数会比指针取数更快，更容易 CPU 缓存
  - 硬盘缓存
  - 数据库缓存，调整参数，SQL 满足 Cargebale 条件，避免 Function 和 Like，更能够命中数据库缓存
  - 网关缓存
  - 网络缓存（CDN）根据文件 Hash 做更新策略或者回源
- 应用缓存的类型，在什么场景下使用？
  - 内存本地缓存，WeakMap，Guava，Caffeine，EVcache，直接放到对象静态属性上作为单例值
    - 不需要多个实例保持一致性，缓存数据量大，**不需要外部失效**，需要高速存取
    - 单次请求或者上下文中的数据
  - 分布式缓存
    - Redis 主流
      - **跨进程共享或者共识**，数据量很大把缓存交给专门的节点，避免应用节点缓存太多数据
    - MemdCache
    - Tair
  - 前端缓存
    - 缓存在用户客户端，使用 Htag 缓存
  - 计算缓存
    - 不涉及 IO，类似递归的记忆化，根据入参比对来记忆化
- 被缓存对象颗粒度，一般缓存什么？
  - Response 为粒度，以用例为视角。比如用户下单，并获取积分
    - 颗粒度大，缓存的效果好（纳入缓存的内容多，包括数据和计算逻辑）
    - 命中概率低，组成 key 的条件太多
      - 如果是偏静态数据，尽量优化为前端缓存或者网关缓存
    - 更新策略不好控制，开发难度比较大，需要加很多代码，需要看业务是否能接受
      - 服务降级的时候
      - 举个例子：用户详情，使用用户 ID 做 Key，相关地方都需要手动刷新，例如地址、积分、消费记录等
    - 有部分电商公司使用该方案，互联网场景，用户基数比较大，并发请求高，取数代价高
    - 缓存 key：一般是 URL 中关键路径
  - 以聚合为粒度，以**原子业务一致性**为视角。比如订单和订单项为单位，积分是另外一个聚合
    - 颗粒度适中，缓存的效果适中
    - 根据聚合根来控制缓存失效
    - 部分数据可能不会被纳入缓存
    - 依赖 DDD 的取数逻辑，为整存整取
    - 缓存 key: 一般是聚合根 ID
  - 以实体（表）为单位。比如订单、订单项分开缓存
    - 颗粒度小，缓存的效果小
    - 可以借助 ORM 框架缓存，Session 内多次获取，可以避免再查询，需要开启二级缓存
    - 缓存 key: 一般是表的主键
- 总结
  - 缓存颗粒度越小，失效策略越好处理，但是缓存住的数据和逻辑就越少
- 特殊场景
  - 列表页查询缓存怎么做？需要加缓存吗？如何更新？
    - 不加缓存，直接走读库 CQRS 模式，或者走 ES，推荐。ES 的更新策略是 COW（Copy On Write） 
    - 查询条件做很短过期的查询（业务容忍范畴），不处理更新
  - 大 Key 怎么处理？
    - 拆分
    - 大 Key 有什么标准和原则？多大算大？
      - 1-10KB 之间根据团队定一个规范
  - 热点 Key，缓存被击穿？什么时候会被击穿？
    - 没有随机失效，失效时间没有 buffer，同时丢失了缓存
  - 缓存穿透？
    - 经常用的数据没有被缓存，只取缓存
- 缓存配置
  - 框架自动
  - 注解 尽量使用注解
  - 手写
- 缓存失效策略
  - 时间
  - 进程内，主动失效
  - 进程间，主动失效，比如服务之间通过 MQ 通知其他服务更新缓存，非常不推荐，反模式
- 缓存时间设定
  - 保持随机性，避免被穿透
- 需要缓存的常见场景
    - 热点数据
      - 用户信息
      - 权限数据
      - 配置表或者元数据
    - 高价值数据
      - 目录树
      - 机构树
      - DashBoard 统计值
    - 大 IO
      - 缓存到前端
      - 上传到 OSS 服务器（Chunk）
- 如何做缓存预热？
  - 使用一个专门的服务，拿到增量数据的 ID，触发缓存加载
  - 使用脚本或者定时任务在服务启动后把高频 API 调用一次
- 如何序列化和反序列化？
  - JSON 序列化 【推荐】
    - 带类型，如何做到安全序列化，比如包挪动后，反序列化还能成功？因为默认序列化有类型信息在 JSON 中
    - 不带类型，反序列化时需要传入类型。【推荐】
  - Java 自带的序列化。【不推荐】
  - ProtetBuffer GRPC 协议，可以减少文件大小，不太好观测
- 如何写出缓存友好的代码？
  - 改写框架，定义过期时间
  - **命令和查询分离**，每个方法不能改上下文且返回数据，尽量拆分两个
  - 私有方法缓存注解不生效
  - 参数尽量用变量不要用对象，找不到缓存键，比如查询用户就用 UserId，别用 User 对象
  - 尽量按照聚合设计方法颗粒度，这样方便更新缓存
- 缓存的原理，下次作为聊面试题
  - LRU 
  - LFU
  - FIFO

## 录屏

链接: https://pan.baidu.com/s/1Xu8ZGbeWRa0rOZRf3B9MVQ?pwd=8r3r 提取码: 8r3r 复制这段内容后打开百度网盘手机App，操作更方便哦




