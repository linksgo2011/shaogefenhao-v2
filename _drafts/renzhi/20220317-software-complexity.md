---
title: 分享 | 软件的复杂性管理
toc: true
categories: 
  - 高认知软件工程星球
sidebar: auto
---

复杂性不会消除，只能被管理，管理的本身又会带来复杂性。

软件工程中的管理，其实就是在解决一起开发的人多了怎么办。在软件工程中，一加一是不等于二的，当人一多麻烦事儿就多，不仅帮不上忙可能还需要额外的管理成本。

架构设计也是类似，复杂度不会消失，拆分是管理复杂度，让局部没那么复杂，管理复杂度的过程反而会增加复杂性。这就是微服务等分布式系统存在的意义。所以分布式系统是业务发展到迫不得已，不是武功秘籍。

在运维方面，由于环境的复杂性，我们得想办法管理。比如引入容器 docker，管理 docker 还得搞个k8s，但是用的人简单了，k8s 中变得更复杂。**为了管理复杂性，会引入更多复杂性。**

所以除非天赋异禀的人能直面复杂性，一个文件写一万行。普通人比起提高智力的途径来面对复杂性，对复杂性进行管理更靠谱。

脑暴一下，管理复杂性的方法有哪些呢？

1. 分解
2. 隔离
3. 外包
4. 封装
5. 市场调节

## 分解

将问题分解，然后一步一步完成。这就是 TDD 中 tasking 的思想，也是之前提到的《谈谈方法》中的方法论。

将任务或者问题分解为子问题。

## 隔离

将架构的能力进行拆分，每个模块对应不同的能力，然后组合。

对能力进行隔离，然后通过契约结合起来。这种契约就是接口，服务之间通过接口共享能力。

## 外包

对架构进一步隔离，将无关痛痒的能力由外部采购的方案实现，将内部资源真正用在刀刃上。

这也是一种更大的分工合作。

## 封装

将成熟的东西沉淀下来，封装工具库、规范、流程、工作方式，这些都算一种封装。

## 市场调节

最后一个脑洞是市场，通过供需关系将复杂性交给看不见的手。比如公司内部，建立奖励机制，通过发布需求的方式让团队主动提供解决方案。

在大型的企业越来越表现得像这种模型。

还有那些呢？



