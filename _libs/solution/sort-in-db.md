---
title: 拖拽排序后端设计方案
toc: true
date: 2021-08-11 19:18:36
categories: 
  - 技术方案
sidebar: auto
permalink: /solution/sort-in-db/
---

## 背景

最近有一个需求，用户需要管理部门下所有的成员。根据显示的成员列表显示拖拽排序，成员的数量比较多，需要分页显示，高达数千条。

![img](./sort-in-db/20190604153235130.gif)



## 全量更新重拍

当用户量较少时，前端全量更新给后端顺序，例如 post 接口，将 ID 的数组发送到后端。



```
[2,3,4,2] 
```

适合首页轮播图管理、任务卡片管理。



## 中值法

原理与实现步骤：

1. 每条记录有一个记录顺序的字段，例如 `index` ，添加记录时按照一定的步长添加。例如 1000 2000 ，这个间隔就是用来实现排序，并最小程度不更新数据库。
2. 当拖拽改变元素位置时，更新 `index`。更新规则如下：
   1. 调整一个元素到两个元素中间时，`(pre_item.index + after_item.index）/ 2 = `index 
   2. 调整一个元素到第一个元素时， `old_first_item.index / 2 = index`
   3. 调整一个元素到最后一个元素时， `old_last_item.index + 65536 = index`
3. 当前后两个元素的数值，不满足整数时，更新所有元素的排序。也就是排序空间不够，触发重排。



注意事项：

- 合理设置步长，理想情况，不触发重排最大排序次数是，步长对于2的对数。
- 触发重排需要设置分布式锁





## 平移法



每个元素，都有一个字段`index`，表示元素的排序信息。
 规定元素从0开始递增。

 基本操作如下：

- 增加数据。 新增元素时，序号为当前元素数据总量值。
- 删除元素。删除元素时，将大于该元素的序号，都减1，后续元素前移。
- 修改元素排序。当元素从 x 移动到 y 时，
  - 若 x < y 时，则将(x, y)范围内的元素都减1，前移
  - 若 x > y 时，则将(y, x)范围内的元素都加1，后移
- 查询元素。展示列表时，按照 `index` 字段进行排序即可。若需要查第n位元素时，元素位置为 `index = n - 1`。

这种方式优点是，查询快，修改慢。而且，修改接口的逻辑较重，处理起来比较麻烦。适合频繁操作，但是对接口性能要求不高的场景。

## 参考资料

- https://www.jianshu.com/p/9ee708e43ebf
